<style>
    * {

        user-select: none;

        -webkit-user-select: none;

        font-family: Helvetica, Arial, sans-serif;

    }

    body {

        width: 100vw;

        height: 100vh;

        margin: 0;

        overflow: hidden;

    }

    .grabber {

        cursor: grab;

    }

    .grabber:active {

        cursor: grabbing;

    }

    #load {

        position: fixed;

        cursor: wait;

        top: 0;

        left: 0;

        width: 100vw;

        height: 100vh;

        background-color: #CCCCCC;

        color: #111111;

        display: flex;

        text-align: center;

        align-items: center;

        justify-content: center;

        padding: 10px;

        box-sizing: border-box;

    }

    #cnv {

        position: fixed;

        top: 0;

        left: 0;

        z-index: 2;

    }
</style>

<script>
    "use strict";



    //Change these variables as needed... 

    var showGrid = false;

    const { round, floor, random, PI } = Math;

    window.onload = function () {

        //Use 2D canvas to create textures.

        var cnv = document.getElementById("cnv");

        var ctx = cnv.getContext("2d");

        var masterSpriteData;

        let W = 81 * 5, H = 91 * 9, D = 108;

        function buildSprite() {

            cnv.width = W;

            cnv.height = H;

            ctx.fillStyle = "#222";

            ctx.fillRect(0, 0, W, H);

            ctx.fillStyle = "#8888FF";

            ctx.shadowColor = "#5555DD";

            ctx.shadowBlur = 7;

            for (let x = 0; x < W * 9; x += 9) {

                for (let y = 0; y < H * 9; y += 9) {

                    if (x % 2 == 1 && y % 2 == 1) {

                        if (round(random() * 100) < 40) {

                            ctx.fillStyle = "#8888FF";

                            ctx.shadowColor = "#5555DD";

                        }

                        else {

                            ctx.fillStyle = "#111";

                            ctx.shadowColor = "transparent";

                        }

                        ctx.fillRect(x, y, 9, 9);

                    }



                }

            }

            ctx.shadowColor = "transparent";

        }

        buildSprite();

        masterSpriteData = ctx.getImageData(0, 0, W, H);

        cnv.style.display = "none";



        function getBuildingFace(w, h) {

            cnv.width = w;

            cnv.height = h;

            let x = -round((W - w) * random() / 18) * 18;

            let y = -round((H - h) * random() / 18) * 18;

            ctx.putImageData(

                masterSpriteData,

                x, y

            );

            ctx.lineWidth = 8;

            ctx.strokeStyle = "#222";

            ctx.strokeRect(0, 0, w, h);

            return cnv.toDataURL();

        }



        // SCENE

        var scene = new THREE.Scene();

        scene.background = new THREE.Color(0xCCCCCC);



        /* /////////////////////////// */



        // CAMERA

        var camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, .01, 800);

        camera.position.set(-2.5, 2, 2.5);



        /* ////////////////////////////////////////// */



        // RENDERER

        var renderer = new THREE.WebGLRenderer({ antialias: true });

        renderer.setSize(window.innerWidth, window.innerHeight);

        renderer.shadowMap.enabled = true;

        renderer.shadowMap.type = THREE.PCFSoftShadowMap;



        // Append canvas to the body

        document.body.appendChild(renderer.domElement);



        /* ////////////////////////////////////////// */



        // Camera Rotation Control

        var controls = new THREE.OrbitControls(camera, renderer.domElement);

        controls.maxPolarAngle = PI / 2.6;

        controls.minPolarAngle = PI / 5;

        controls.minDistance = 3;

        controls.maxDistance = 7;

        controls.enablePan = false;

        controls.enabled = false;

        controls.autoRotateSpeed = -2;



        //let Fog = new THREE.Fog(0x000000, 2);

        //scene.add(Fog)



        if (showGrid) {

            const size = 10;

            const divisions = 10;



            const gridHelper = new THREE.GridHelper(size, divisions);

            scene.add(gridHelper);

        }





        function makeBuilding(i) {

            let l = 63 + 18 * round(10 * random());//243

            let w = l;//63 + 18*round(10*random());

            let h = 135 + 18 * round(38 * random());//819

            //console.log(819/(D*4))

            let boxGeo = new THREE.BoxGeometry(l / (D * 4), h / (D * 4), w / (D * 4));



            let materialArray = [];

            let texture_ft = new THREE.TextureLoader().load(getBuildingFace(w, h));

            let texture_bk = new THREE.TextureLoader().load(getBuildingFace(w, h));

            let texture_rt = new THREE.TextureLoader().load(getBuildingFace(l, h));

            let texture_lf = new THREE.TextureLoader().load(getBuildingFace(l, h));



            materialArray.push(new THREE.MeshPhongMaterial({ map: texture_ft }));

            materialArray.push(new THREE.MeshPhongMaterial({ map: texture_bk }));

            materialArray.push(new THREE.MeshPhongMaterial({ color: new THREE.Color("#111"), }));

            materialArray.push(new THREE.MeshPhongMaterial({ color: 0x000000, }));

            materialArray.push(new THREE.MeshPhongMaterial({ map: texture_rt }));

            materialArray.push(new THREE.MeshPhongMaterial({ map: texture_lf }));





            let box = new THREE.Mesh(boxGeo, materialArray);

            box.position.set((-2 + floor(i / 5)) / 1.5, h / (D * 8), (-2 + i % 5) / 1.5);

            box.rotation.y = PI / 4;

            box.castShadow = true;

            box.receiveShadow = true;

            scene.add(box);

        }

        let i = 0;

        function add() {

            if (i < 25) {

                makeBuilding(i);

                i++;

                setTimeout(add, 150);

            }

            else {

                i = 0;

                setTimeout(setScene, 500);

            }

        }

        function setScene() {

            if (i == 1) {

                scene.background = new THREE.Color(0x070710);

            }

            else if (i == 2) {

                let glow = new THREE.AmbientLight(0xFFFFFF, 1);

                scene.add(glow);

            }

            else if (i == 0) {

                let BaseGeo = new THREE.CircleGeometry(25, 32);

                let BaseMat = new THREE.MeshPhongMaterial({ color: 0x101010, side: THREE.DoubleSide });

                let Base = new THREE.Mesh(BaseGeo, BaseMat);

                Base.rotation.x = -PI / 2;

                Base.castShadow = false;

                Base.receiveShadow = true;

                scene.add(Base);

            }

            else if (i == 4) {

                let L = new THREE.DirectionalLight(0xCCCCCC, 0.5);

                L.position.set(3, 2, -3);

                L.castShadow = true;

                L.shadow.mapSize.width = 512;

                L.shadow.mapSize.height = 512;

                L.shadow.camera.near = 0.5;

                L.shadow.camera.far = 500;

                scene.add(L);

            }

            else if (i == 3) {

                let moonGeo = new THREE.SphereGeometry(40);

                let moonMat = new THREE.MeshBasicMaterial({ color: 0xCCCCCC });

                let moon = new THREE.Mesh(moonGeo, moonMat);

                moon.position.set(500, 100, -500);

                scene.add(moon);

            }

            else {

                let L = new THREE.PointLight(0xFF0000, 0.5, 0, 2);

                L.position.set(

                    (-1.5 + floor((i - 5) / 4)) / 1.5,

                    -0.5,

                    (-1.5 + (i - 5) % 4) / 1.5,

                );

                scene.add(L);

            }

            i++;

            if (i < 21) setTimeout(setScene, 500);

            else {

                controls.enabled = true;

                controls.autoRotate = true;

                renderer.domElement.classList.add("grabber");

            }

        }





        // Render animation on every rendering phase

        function render() {

            requestAnimationFrame(render);

            renderer.render(scene, camera); // Render Scene and Camera

            controls.update(); // For Orbit Controller

        }

        load.innerHTML = "Wait for the animation to finish. After that orbit controls will be enabled.<br>Click to continue...";

        load.addEventListener("click", function () {

            this.parentNode.removeChild(this);

            render();

            add();

        });

        load.style.cursor = "pointer";



        /*///////////////////////////////*/



        // Update Camera Aspect Ratio and Renderer ScreenSize on Window resize

        window.addEventListener('resize', function () {

            camera.aspect = window.innerWidth / window.innerHeight;

            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        }, false);

    }

    /*////////////////////////////////*/</script>

<!DOCTYPE html>

<html>

<head>
    <meta charset="utf-8">

    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <title>Build_A_City</title>

    <script src="https://cdn.jsdelivr.net/npm/three@0.145.0/build/three.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/three@0.145.0/examples/js/controls/OrbitControls.js"></script>

</head>

<body>

    <canvas id="cnv"></canvas>

    <div id="load">Loading..</div>

</body>

</html>